<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3279 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3279.xml">
<!ENTITY rfc4055 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml">
<!ENTITY rfc5280 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY rfc5480 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5480.xml">
<!ENTITY rfc5639 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5639.xml">
<!ENTITY rfc5755 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5755.xml">
<!ENTITY rfc5758 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5758.xml">
<!ENTITY rfc5915 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5915.xml">
<!ENTITY rfc5958 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5958.xml">
<!ENTITY rfc7468 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7468.xml">
<!ENTITY rfc7748 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7748.xml">
<!ENTITY rfc8174 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY eddsa   SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml">
<!ENTITY iana SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.schaad-curdle-oid-registry.xml">
]>

<?rfc strict="yes" ?>
<?rfc compact="no"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-curdle-pkix-09">
     
  <front>
    
    <title abbrev="Safe curves for X.509">
      <!-- Remove PH 
           Algorithm Identifiers for Ed25519, Ed25519ph, Ed448, Ed448ph, X25519 and X448 for use in the Internet X.509 Public Key Infrastructure
-->           
      Algorithm Identifiers for Ed25519, Ed448, X25519 and X448 for use in the Internet X.509 Public Key Infrastructure
    </title>
    
    <author fullname="Simon Josefsson" initials="S." surname="Josefsson">
      <organization>SJD AB</organization>
      <address>
        <email>simon@josefsson.org</email>
      </address>
    </author>

    <author fullname="Jim Schaad" initials="J" surname="Schaad">
      <organization>August Cellars</organization>
      <address>
        <email>ietf@augustcellars.com</email>
      </address>
    </author>

    <date/>

    <keyword>Elliptic Curve Cryptography, Curve25519, Curve448,
    Goldilocks, X.509, PKIX, PKI, OID, ASN.1, EdDSA,
    Ed25519, Ed448, X25519, X448</keyword>

    <abstract>

      <t>This document specifies algorithm identifiers and ASN.1
      encoding formats for Elliptic Curve constructs using the curve25519 and curve448 curves.
      <!-- Remove ph
           The signature algorithms covered are Ed25519, Ed25519ph, Ed448 and Ed448ph.
           -->
      The signature algorithms covered are Ed25519 and Ed448.
      The key agreement algorithm covered are X25519 and X448.
      The encoding for Public Key, Private Key and EdDSA digital signature structures is provided.
      </t>

    </abstract>

  </front>

  <middle>

    <section title="Introduction">

      <t>
        In <xref target="RFC7748"/>, the elliptic curves curve25519
      and curve448 are described.  They are designed with performance
      and security in mind.  The curves may be used for Diffie-Hellman
      and Digital Signature operations.
      </t>

      <t>
        <xref target="RFC7748"/> describes the operations on these curves for the Diffie-Hellman operation.
        A convention has developed that when these two curves are used with the Diffie-Hellman operation, they are referred to as X25519 and X448.
        This RFC defines the ASN.1 Object Identifiers (OIDs) for the operations X25519 and X448 along with the associated parameters.
        The use of these OIDs is described for public and private keys.
      </t>
        

      <t>
        In <xref target="RFC8032"/> the elliptic curve signature system Edwards-curve Digital Signature Algorithm (EdDSA) is described along with a recommendation for the use of the curve25519 and curve448.
        EdDSA has defined two modes, the PureEdDSA mode without pre-hashing, and the HashEdDSA mode with pre-hashing.
        <!-- Remove pre-hash
             The Ed25519ph and Ed448ph algorithm definitions specify the one-way hash function that is used for pre-hashing.
             The convention used for identifying the algorithm/curve combinations are to use the Ed25519 and Ed448 for the PureEdDSA mode, with Ed25519ph and Ed448ph for the HashEdDSA mode.
             -->
        The convention used for identifying the algorithm/curve combinations is to use "Ed25519" and "Ed448" for the PureEdDSA mode.
        The document does not provide the conventions needed for the pre-hash versions of the signature algorithm.
        The use of the OIDs is described for public keys, private keys and signatures.
      </t>

      <t>
        <xref target="RFC8032"/> additionally defined the concept of a context.
        Contexts can be used to differentiate signatures generated for different purposes with the same key.
        The use of contexts is not defined in this document for the following reasons:
        <list style="symbols">
          <t>The current implementations of Ed25519 do not support the use of contexts, thus if specified it will potentially delay the use of these algorithms further.</t>
          <t>
            The EdDSA algorithms  are the only IETF algorithms that currently support the use of contexts, however there is a possibility that there will be confusion between which algorithms need to have separate keys and which do not.
            This may result in a decrease of security for those other algorithms.
          </t>
          <t>
            There are still ongoing discussions among the cryptographic community about how effective the use of contexts is for preventing attacks.
          </t>
          <t>
            There needs to be discussions about the correct way to identify when context strings are to be used.
            It is not clear if different OIDs should be used for different contexts, or the OID should merely note that a context string needs to be provided.
          </t>
        </list>
      </t>
    </section>

    <section title="Requirements Terminology">

      <t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119" /> <xref target="RFC8174"/> when, and only when, they
      appear in all capitals, as shown here.
      </t>

    </section>

    <section title="Curve25519 and Curve448 Algorithm Identifiers">

      <t>Certificates conforming to <xref target="RFC5280"/> can
      convey a public key for any public key algorithm.  The
      certificate indicates the algorithm through an algorithm
      identifier.  This algorithm identifier is an OID and optionally
      associated parameters.
      </t>
      
      <t>The AlgorithmIdentifier type, which is included for
      convenience, is defined as follows:</t>

      <figure>
        <artwork><![CDATA[
AlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm   OBJECT IDENTIFIER,
    parameters  ANY DEFINED BY algorithm OPTIONAL
}
]]></artwork>
      </figure>

      <t>The fields in AlgorithmIdentifier have the following
      meanings:</t>

      <t><list style="symbols">
        <t>algorithm identifies the cryptographic algorithm with an
        object identifier.  Four such OIDs are defined below.</t>

        <t>parameters, which are optional, are the associated
        parameters for the algorithm identifier in the algorithm
        field.
        When the 1997 syntax for AlgorithmIdentifier was initially defined, it omitted the OPTIONAL key word.
        The optionality of the parameters field was later recovered via a defect report, but by then many people thought that the field was mandatory.
        <!-- M00TODO - Per Adam's review - delete this sentence? 
        For this reason, a small number of implementations may still require the field to be present.-->
        </t>
      </list></t>

      <t>
        <!-- RFC Editor:  I have been told that the following three sentences should be joined together, I tend to think
             that they are correct as separate items but it is something that a copy editor should look at -->
        In this document we define four new OIDs for identifying the different curve/algorithm pairs.
        The curves being curve25519 and curve448.
        The algorithms being ECDH and EdDSA in pure mode. <!--  and EdDSA in pre-hash mode. -->
        For all of the OIDs, the parameters MUST be absent.
        Regardless of the defect in the original 1997 syntax, implementations MUST NOT accept a parameters value of NULL.
      </t>

      <t>
        The same algorithm identifiers are used for identifying a public key, identifying a private key and identifying a signature (for the two EdDSA related OIDs).
        Additional encoding information is provided below for each of these locations.
      </t>

      <!--  Remove pre-hash algorithms
        id-Ed25519ph OBJECT IDENTIFIER ::= { 1 3 101 114 }
        id-Ed448ph   OBJECT IDENTIFIER ::= { 1 3 101 115 }
      -->
      
      <figure>
        <artwork><![CDATA[
id-X25519    OBJECT IDENTIFIER ::= { 1 3 101 110 }
id-X448      OBJECT IDENTIFIER ::= { 1 3 101 111 }
id-Ed25519   OBJECT IDENTIFIER ::= { 1 3 101 112 }
id-Ed448     OBJECT IDENTIFIER ::= { 1 3 101 113 }
]]></artwork>
      </figure>

      <!--
      <t>The OID id-Curve25519 refers to Curve25519.  The OID
      id-Curve448 refers to Curve448.  Both curves are described in
      <xref target="RFC7748"/>.  The OIDs id-Curve25519ph and
      id-Curve448ph refers to Curve25519 and Curve448 when used with
      pre-hashing as Ed25519ph and Ed448ph described in <xref
      target="RFC8032"/>.</t>
      
      <t>The public key value encoded into the ECPoint value is the
      raw binary values described in <xref target="RFC7748"/>.</t>
      -->

    </section>

    <section title="Subject Public Key Fields">

      <t>In the X.509 certificate, the subjectPublicKeyInfo field has
      the SubjectPublicKeyInfo type, which has the following ASN.1
      syntax:</t>

      <figure>
        <artwork><![CDATA[
SubjectPublicKeyInfo  ::=  SEQUENCE  {
    algorithm         AlgorithmIdentifier,
    subjectPublicKey  BIT STRING
}
]]></artwork>
      </figure>

      <t>The fields in SubjectPublicKeyInfo have the following meanings:</t>

      <t><list style="symbols">
        <t>algorithm is the algorithm identifier and parameters for
        the public key (see above).</t>

        <t>subjectPublicKey contains the byte stream of the public key.
        The algorithms defined in this document always encode the public key as an exact multiple of 8-bits.
        </t>
      </list></t>

      <t>
        Both <xref target="RFC7748"/> and <xref target="RFC8032"/> define the public key value as being a byte string.
        It should be noted that the public key is computed differently for each of these documents, thus the same private key will not produce the same public key.
      </t>

      <t>The following is an example of a public key encoded using the  textual encoding defined in  <xref target="RFC7468"/>.</t>

      <figure>
<artwork><![CDATA[
-----BEGIN PUBLIC KEY-----
MCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=
-----END PUBLIC KEY-----      
]]></artwork>
      </figure>
    </section>

    <!--
    <section title="EdDSA Public Keys">

      <t>Certificates conforming to <xref target="RFC5280"/> may
      convey a public key for any public key algorithm.  The
      certificate indicates the algorithm through an algorithm
      identifier.  This algorithm identifier is an OID and optionally
      associated parameters.</t>

      <t>This section identify the OID and parameters for the EdDSA
      algorithm.  Conforming CAs MUST use the identified OIDs when
      issuing certificates containing EdDSA public keys.  Conforming
      applications supporting EdDSA MUST, at a minimum, recognize the
      OID identified in this section.</t>

      <t>The id-EdDSAPublicKey OID is used for identifying EdDSA
      public keys.</t>

      <figure>
      <artwork><![CDATA[
       id-EdDSAPublicKey OBJECT IDENTIFIER ::= { 1 3 101 100 }
       ]]></artwork>
      </figure>

      <t>The id-EdDSAPublicKey OID is intended to be used in the
      algorithm field of a value of type AlgorithmIdentifier.</t>

      <t>EdDSA public keys use the parameter field to specify the
      particular instantiation of EdDSA parameters.  The parameters
      field have the ASN.1 type EdDSAParameters as follows.</t>

      <figure>
      <artwork><![CDATA[
      EdDSAParameters ::= ENUMERATED { ed25519   (1),
          ed25519ph (2) }
          ed448     (3) }
          ed448ph   (4) }
]]></artwork>
     </figure>

      <t>The EdDSAParameters enumeration may be extended in the
      future.</t>

      <t>The "ed25519" and "ed448" values correspond to the PureEdDSA
      variants, and the "ed25519ph" and "ed448ph" values correspond to
      the HashEdDSA variants, as discussed in <xref
      target="RFC8032"/>.</t>

      <t>The raw binary EdDSA public key is encoded directly in the
      subjectPublicKey BIT STRING object.  Note that unlike some other
      schemes, there is no additional OCTET STRING encoding step.</t>

</section>
-->
    
    <section title="Key Usage Bits">
      
      <t>The intended application for the key is indicated in the
      keyUsage certificate extension.</t>

      <t>
        If the keyUsage extension is present in a certificate that indicates
        id-X25519 or id-X448 in SubjectPublicKeyInfo, then the following MUST
        be present:
      </t>

      <figure><artwork>
        keyAgreement;
      </artwork></figure>

      <t>
        one of the following MAY also be present:
      </t>

      <t>
        <figure><artwork>
          encipherOnly; or
          decipherOnly.
          </artwork>
        </figure>
      </t>

      <t>
        If the keyUsage extension is present in an end-entity
        <!-- Remove pre-hash
      certificate that indicates id-EdDSA25519, id-EdDSA25519ph, id-EdDSA448 or id-EdDSA448ph
        -->
      certificate that indicates id-Ed25519 or id-Ed448, then the keyUsage extension
      MUST contain one or both of the following values:</t>

      <figure>
        <artwork><![CDATA[
        nonRepudiation; and
        digitalSignature.
]]></artwork>
      </figure>

      <t>If the keyUsage extension is present in a certification
      authority certificate that indicates id-Ed25519 or id-Ed448, then the keyUsage extension
      MUST contain one or more of the following values:</t>

      <figure>
<artwork><![CDATA[
       nonRepudiation;
       digitalSignature;
       keyCertSign; and
       cRLSign.
       ]]></artwork>
      </figure>

        <!-- Remove pre-hash
        <t>
        CAs MUST NOT use the pre-hash versions of the EdDSA algorithms for the creation of certificates or CRLs.
        This is implied by the fact that those algorithms are not listed in the previous paragraph.
        Additionally OCSP responders SHOULD NOT use the pre-hash versions of the EdDSA algorithms when generating OCSP responses.
        No restriction is placed on generation of OCSP requests.
        </t>


      <t>
        AAs MUST NOT use the pre-hash versions of the EdDSA algorithms for the creation of attribute certificates or attribute CRLs <xref target="RFC5755"/>.
      </t>

      <t>
        The decision to require the use of pure mode balances the higher security of having a single failure point against the possibility that constrained devices, such as Hardware Security Modules (HSMs), may be unable to check signatures on CRLs due to the amount of memory required to hold the entire CRL in memory at one time.
        This concern can be addressed by CAs using CRL distribution points, combined with segmenting the certificates issued so that the length of any segmented CRL is not "too long" even if a large percentage of the certificates are revoked.
        The definition of "too long" is going to be highly dependent on what constrained device is being used, it can be on the order of single or low double digit kilobytes.
      </t>
        -->
        

    </section>

    <section title="EdDSA Signatures">

      <t>
        Signatures can be placed in a number of different ASN.1 structures.
        The top level structure for a certificate is given below as being illustrative of how signatures are frequently encoded with an algorithm identifier and a location for the signature.
      </t>


      <figure>
<artwork><![CDATA[
   Certificate  ::=  SEQUENCE  {
        tbsCertificate       TBSCertificate,
        signatureAlgorithm   AlgorithmIdentifier,
        signatureValue       BIT STRING  }
]]></artwork>
      </figure>

      <t>
        The same algorithm identifiers are used for signatures as are used for public keys.
        When used to identify signature algorithms, the parameters MUST be absent.
      </t>

      <t>The data to be signed is prepared for EdDSA.  Then, a private
      key operation is performed to generate the signature value.
      This value is the opaque value ENC(R) || ENC(S) described in
      section 3.3 of <xref target="RFC8032"/>.
      
      The octet string representing the signature is encoded directly in the BIT STRING without adding any additional ASN.1 wrapping.
      For the Certificate structure, the signature value is wrapped in the "signatureValue" BIT STRING field.
      </t>

      <!-- Remove Prehash
      <t>
        When the pre-hash versions of the EdDSA signature algorithms are used, the hash function used for the pre-hash is defined by the algorithm.
        This means that the pre-hash function is implicitly included in the algorithm identifier rather than being explicit as done in <xref target="RFC3279"/>.
        </t>
        -->

      
    </section>

    <section title="Private Key Format">

      <t>
        <xref target="RFC5958">Asymmetric Key Packages</xref> describes how to encode a private key in a structure that both identifies what algorithm the private key is for, but allows for the public key and additional attributes about the key to be included as well.
        For illustration, the ASN.1 structure OneAsymmetricKey is replicated below.
        The algorithm specific details of how a private key is encoded is left for the document describing the algorithm itself.
      </t>
      
      <figure>
        <artwork><![CDATA[
OneAsymmetricKey ::= SEQUENCE {
   version Version,
   privateKeyAlgorithm PrivateKeyAlgorithmIdentifier,
   privateKey PrivateKey,
   attributes [0] IMPLICIT Attributes OPTIONAL,
   ...,
   [[2: publicKey [1] IMPLICIT PublicKey OPTIONAL ]],
   ...
}

PrivateKey ::= OCTET STRING

PublicKey ::= BIT STRING
]]></artwork>
      </figure>

      <t>
        For the keys defined in this document, the private key is always an opaque byte sequence.
        The ASN.1 type CurvePrivateKey is defined in this document to hold the byte sequence.
        Thus when encoding a OneAsymmetricKey object, the private key is wrapped in an CurvePrivateKey object and wrapped by the OCTET STRING of the "privateKey" field.
      </t>

      <figure>
      <artwork><![CDATA[
CurvePrivateKey ::= OCTET STRING
]]></artwork>
      </figure>
      
      <t>
To encode a EdDSA, X25519 or X448 private key, the
"privateKey" field will hold the encoded private key.
The "privateKeyAlgorithm" field uses the AlgorithmIdentifier structure.
The structure is encoded as defined above.
If present, the "publicKey" field will hold the encoded key as defined in <xref target="RFC7748"/> and <xref target="RFC8032"/>.
      </t>

      <t>The following is an example of a private key encoded using the textual encoding defined in  <xref target="RFC7468"/>.</t>

      <figure>
<artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06/nwoy/HU++CXqI9EdVhC
-----END PRIVATE KEY-----
]]></artwork>
      </figure>

      <t>
        The following example, in addition to encoding the private key, additionally has an attribute included as well as the public key.
        As with the prior example, the textual  encoding defined in <xref target="RFC7468"/> is used.
      </t>
      <figure>
        <artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MHICAQEwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06/nwoy/HU++CXqI9EdVhC
oB8wHQYKKoZIhvcNAQkJFDEPDA1DdXJkbGUgQ2hhaXJzgSEAGb9ECWmEzf6FQbrB
Z9w7lshQhqowtrbLDFw4rXAxZuE=
-----END PRIVATE KEY------]]></artwork>
      </figure>

      <t>
        NOTE: There exist some private key import functions that have not picked up the new ASN.1 structure OneAsymmetricKey that is defined in <xref target="RFC7748"/>.
        This means that they will not accept a private key structure which contains the public key field.
        This means a balancing act needs to be done between being able to do a consistency check on the key pair and widest ability to import the key.
      </t>
    </section>

    <section title="Human Readable Algorithm Names">

      <t>For the purpose of consistent cross-implementation naming,
      this section establishes human readable names for the algorithms
      specified in this document.  Implementations SHOULD use these
      names when referring to the algorithms.  If there is a strong
      reason to deviate from these names -- for example, if the
      implementation has a different naming convention and wants to
      maintain internal consistency -- it is encouraged to deviate as
      little as possible from the names given here.</t>

      <t>Use the string "ECDH" when referring to a public key of type "X25519" or "X448" when the curve is not known or relevant.</t>

      <t>When the curve is known, use the more specific string of "X25519" or "X448".</t>
      
      
      <t>Use the string "EdDSA" when referring to a signing public key or
      signature when the curve is not known or relevant.</t>

      <t>When the curve is known, use a more specific
      string. 
      For the id-Ed25519 value use the string "Ed25519".
      <!-- Remove pre-hash
      For
      the id-EdDSA25519ph value use the string "Ed25519ph".  --> For id-Ed448
      use "Ed448".  <!-- Remvoe prehash For id-EdDSA448ph use "Ed448ph".--></t>
      
    </section>

    <section title="ASN.1 Module" anchor="module">

      <t>For reference purposes, the ASN.1 syntax is presented as an
      ASN.1 module here.</t>

      <figure>
<artwork><![CDATA[
-- ASN.1 Module

Safecurves-pkix-0 -- TBD - IANA assigned module OID

DEFINITIONS EXPLICIT TAGS ::=
BEGIN

IMPORTS
  SIGNATURE-ALGORITHM, KEY-AGREE, PUBLIC-KEY, KEY-WRAP,
  KeyUsage, AlgorithmIdentifier
  FROM AlgorithmInformation-2009 
    {iso(1) identified-organization(3) dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) id-mod(0)
    id-mod-algorithmInformation-02(58)}

  mda-sha512
  FROM PKIX1-PSS-OAEP-Algorithms-2009
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkix1-rsa-pkalgs-02(54) }

  kwa-aes128-wrap, kwa-aes256-wrap
  FROM CMSAesRsaesOaep-2009
    { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
      smime(16) modules(0) id-mod-cms-aes-02(38) }
  ;
    

id-edwards-curve-algs OBJECT IDENTIFIER ::= { 1 3 101 }

id-X25519        OBJECT IDENTIFIER ::= { id-edwards-curve-algs 110 }
id-X448          OBJECT IDENTIFIER ::= { id-edwards-curve-algs 111 }
id-Ed25519       OBJECT IDENTIFIER ::= { id-edwards-curve-algs 112 }
id-Ed448         OBJECT IDENTIFIER ::= { id-edwards-curve-algs 113 }


 sa-Ed25519 SIGNATURE-ALGORITHM ::= {
    IDENTIFIER id-Ed25519
     PARAMS ARE absent
     PUBLIC-KEYS {pk-Ed25519}
     SMIME-CAPS { IDENTIFIED BY id-Ed25519 }
 }

 pk-Ed25519 PUBLIC-KEY ::= {
     IDENTIFIER id-Ed25519
     -- KEY no ASN.1 wrapping --
     PARAMS ARE absent
     CERT-KEY-USAGE {digitalSignature, nonRepudiation,
                     keyCertSign, cRLSign}
     PRIVATE-KEY CurvePrivateKey
 }

 kaa-X25519 KEY-AGREE ::= {
     IDENTIFIER id-X25519
     PARAMS ARE absent
     PUBLIC-KEYS {pk-X25519}
     UKM -- TYPE no ASN.1 wrapping -- ARE preferredPresent
     SMIME-CAPS {
        TYPE AlgorithmIdentifier{KEY-WRAP, {KeyWrapAlgorithms}}
        IDENTIFIED BY id-X25519 }
 }

 pk-X25519 PUBLIC-KEY ::= {
     IDENTIFIER id-X25519
     -- KEY no ASN.1 wrapping --
     PARAMS ARE absent
     CERT-KEY-USAGE { keyAgreement }
     PRIVATE-KEY CurvePrivateKey
 }

 KeyWrapAlgorithms KEY-WRAP ::= {
     kwa-aes128-wrap | kwa-aes256-wrap,
     ...
 }
     
 kaa-X448 KEY-AGREE ::= {
     IDENTIFIER id-X448
     PARAMS ARE absent
     PUBLIC-KEYS {pk-X448}
     UKM -- TYPE no ASN.1 wrapping  -- ARE preferredPresent
     SMIME-CAPS {
        TYPE AlgorithmIdentifier{KEY-WRAP, {KeyWrapAlgorithms}}
        IDENTIFIED BY id-X448 }
 }

 pk-X448 PUBLIC-KEY ::= {
     IDENTIFIER id-X448
     -- KEY no ASN.1 wrapping --
     PARAMS ARE absent
     CERT-KEY-USAGE { keyAgreement }
     PRIVATE-KEY CurvePrivateKey
 }

CurvePrivateKey ::= OCTET STRING
    
                                 
END
]]></artwork>
      </figure>

    </section>

    <section title="Examples">

      <t>This section contains illustrations of EdDSA public keys and
      certificates, illustrating parameter choices.</t>


      <section title="Example Ed25519 Public Key">

<t>An example of a Ed25519 public key:</t>

<figure>
  <artwork><![CDATA[
      Public Key Information:
          Public Key Algorithm: Ed25519
          Algorithm Security Level: High

      Public Key Usage:
      
      Public Key ID: 9b1f5eeded043385e4f7bc623c5975b90bc8bb3b
      
      -----BEGIN PUBLIC KEY-----
      MCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=
      -----END PUBLIC KEY-----
]]></artwork>
</figure>
      
      </section>

      <section title="Example X25519 Certificate">

<t>An example of a self issued PKIX certificate using Ed25519 to sign a X25519 public key would be:</t>

<figure>
  <artwork><![CDATA[
  0 300: SEQUENCE {
  4 223:   SEQUENCE {
  7   3:     [0] {
  9   1:       INTEGER 2
       :       }
 12   8:     INTEGER 56 01 47 4A 2A 8D C3 30
 22   5:     SEQUENCE {
 24   3:       OBJECT IDENTIFIER
       :         Ed 25519 signature algorithm { 1 3 101 112 }
       :       }
 29  25:     SEQUENCE {
 31  23:       SET {
 33  21:         SEQUENCE {
 35   3:           OBJECT IDENTIFIER commonName (2 5 4 3)
 40  14:           UTF8String 'IETF Test Demo'
       :           }
       :         }
       :       }
 56  30:     SEQUENCE {
 58  13:       UTCTime 01/08/2016 12:19:24 GMT
 73  13:       UTCTime 31/12/2040 23:59:59 GMT
       :       }
 88  25:     SEQUENCE {
 90  23:       SET {
 92  21:         SEQUENCE {
 94   3:           OBJECT IDENTIFIER commonName (2 5 4 3)
 99  14:           UTF8String 'IETF Test Demo'
       :           }
       :         }
       :       }
115  42:     SEQUENCE {
117   5:       SEQUENCE {
119   3:         OBJECT IDENTIFIER
       :           ECDH 25519 key agreement { 1 3 101 110 }
       :         }
124  33:       BIT STRING
       :         85 20 F0 09 89 30 A7 54 74 8B 7D DC B4 3E F7 5A
       :         0D BF 3A 0D 26 38 1A F4 EB A4 A9 8E AA 9B 4E 6A
       :       }
159  69:     [3] {
161  67:       SEQUENCE {
163  15:         SEQUENCE {
165   3:           OBJECT IDENTIFIER basicConstraints (2 5 29 19)
170   1:           BOOLEAN TRUE
173   5:           OCTET STRING, encapsulates {
175   3:             SEQUENCE {
177   1:               BOOLEAN FALSE
       :               }
       :             }
       :           }
180  14:         SEQUENCE {
182   3:           OBJECT IDENTIFIER keyUsage (2 5 29 15)
187   1:           BOOLEAN FALSE
190   4:           OCTET STRING, encapsulates {
192   2:             BIT STRING 3 unused bits
       :               '10000'B (bit 4)
       :             }
       :           }
196  32:         SEQUENCE {
198   3:           OBJECT IDENTIFIER subjectKeyIdentifier (2 5 29 14)
203   1:           BOOLEAN FALSE
206  22:           OCTET STRING, encapsulates {
208  20:             OCTET STRING
       :               9B 1F 5E ED ED 04 33 85 E4 F7 BC 62 3C 59 75
       :               B9 0B C8 BB 3B
       :             }
       :           }
       :         }
       :       }
       :     }
230   5:   SEQUENCE {
232   3:     OBJECT IDENTIFIER
       :       Ed 25519 signature algorithm { 1 3 101 112 }
       :     }
237  65:   BIT STRING
       :     AF 23 01 FE DD C9 E6 FF C1 CC A7 3D 74 D6 48 A4
       :     39 80 82 CD DB 69 B1 4E 4D 06 EC F8 1A 25 CE 50
       :     D4 C2 C3 EB 74 6C 4E DD 83 46 85 6E C8 6F 3D CE
       :     1A 18 65 C5 7A C2 7B 50 A0 C3 50 07 F5 E7 D9 07
       :   }
      
-----BEGIN CERTIFICATE-----
MIIBLDCB36ADAgECAghWAUdKKo3DMDAFBgMrZXAwGTEXMBUGA1UEAwwOSUVURiBUZX
N0IERlbW8wHhcNMTYwODAxMTIxOTI0WhcNNDAxMjMxMjM1OTU5WjAZMRcwFQYDVQQD
DA5JRVRGIFRlc3QgRGVtbzAqMAUGAytlbgMhAIUg8AmJMKdUdIt93LQ+91oNvzoNJj
ga9OukqY6qm05qo0UwQzAPBgNVHRMBAf8EBTADAQEAMA4GA1UdDwEBAAQEAwIDCDAg
BgNVHQ4BAQAEFgQUmx9e7e0EM4Xk97xiPFl1uQvIuzswBQYDK2VwA0EAryMB/t3J5v
/BzKc9dNZIpDmAgs3babFOTQbs+BolzlDUwsPrdGxO3YNGhW7Ibz3OGhhlxXrCe1Cg
w1AH9efZBw==
-----END CERTIFICATE-----
]]></artwork>
</figure>

      </section>

      <section title="Examples of Ed25519 Private Key">
        <t>
          An example of an Ed25519 private key without the public key:
        </t>
    
      <figure>
<artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06/nwoy/HU++CXqI9EdVhC
-----END PRIVATE KEY-----
]]></artwork>
      </figure>

      <t>The same item dumped as ASN.1 yields:
      </t>

      <figure><artwork>
 0 30   46: SEQUENCE {
 2 02    1:   INTEGER 0
 5 30    5:   SEQUENCE {
 7 06    3:     OBJECT IDENTIFIER
          :       Ed 25519 signature algorithm { 1 3 101 112 }
          :     }
12 04   34:   OCTET STRING
          :     04 20 D4 EE 72 DB F9 13 58 4A D5 B6 D8 F1 F7 69
          :     F8 AD 3A FE 7C 28 CB F1 D4 FB E0 97 A8 8F 44 75
          :     58 42
          :   }
          </artwork>
      </figure>

      <t>
        Note that the value of the private key is:
      </t>

      <figure><artwork>
D4 EE 72 DB F9 13 58 4A D5 B6 D8 F1 F7 69 F8 AD
3A FE 7C 28 CB F1 D4 FB E0 97 A8 8F 44 75 58 42
</artwork></figure>


        <t>
          An example of the same Ed25519 private key encoded with an attribute and the public key:
        </t>
    
      <figure>
<artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MHICAQEwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06/nwoy/HU++CXqI9EdVhC
oB8wHQYKKoZIhvcNAQkJFDEPDA1DdXJkbGUgQ2hhaXJzgSEAGb9ECWmEzf6FQbrB
Z9w7lshQhqowtrbLDFw4rXAxZuE=
-----END PRIVATE KEY-----
]]></artwork>
      </figure>

      <t>The same item dumped as ASN.1 yields:
      </t>

      <figure><artwork>
  0 114: SEQUENCE {
  2   1:   INTEGER 1
  5   5:   SEQUENCE {
  7   3:     OBJECT IDENTIFIER '1 3 101 112'
       :     }
 12  34:   OCTET STRING, encapsulates {
       :     04 20 D4 EE 72 DB F9 13 58 4A D5 B6 D8 F1 F7 69
       :     F8 AD 3A FE 7C 28 CB F1 D4 FB E0 97 A8 8F 44 75
       :     58 42
       :     }
 48  31:   [0] {
 50  29:     SEQUENCE {
 52  10:       OBJECT IDENTIFIER '1 2 840 113549 1 9 9 20'
 64  15:       SET {
 66  13:         UTF8String 'Curdle Chairs'
       :         }
       :       }
       :     }
81  33:   [1] 00 19 BF 44 09 69 84 CD FE 85 41 BA C1 67 DC 3B
              96 C8 50 86 AA 30 B6 B6 CB 0C 5C 38 AD 70 31 66
              E1
       :   }
          </artwork>
      </figure>

    </section>
  </section>
  
    <section anchor="ack"
             title="Acknowledgments">

      <t>Text and/or inspiration were drawn from <xref
      target="RFC5280"/>, <xref target="RFC3279"/>, <xref
      target="RFC4055"/>, <xref target="RFC5480"/>, and <xref
      target="RFC5639"/>.</t>

      <t>The following people discussed the document and provided
      feedback: Klaus Hartke, Ilari Liusvaara, Erwann Abalea, Rick
      Andrews, Rob Stradling, James Manger, Nikos Mavrogiannopoulos,
      Russ Housley, David Benjamin, Brian Smith, and Alex Wilson.</t>

      <t>A big thank you to Symantec for kindly donating the OIDs used
      in this draft.</t>
      
    </section>

    <section title="IANA Considerations">

      <t>
        IANA is requested to assign a module OID from the "SMI for PKIX Module Identifier" registry for the ASN.1 module in <xref target="module"/>.
      </t>

      <t>
	The OIDs are being independently registered in the IANA registry "SMI Security for Cryptographic Algorithms" in  <xref target="I-D.schaad-curdle-oid-registry"/>.
      </t>

    </section>

    <section anchor="Security" title="Security Considerations">

      <t>
        The security considerations of <xref target='RFC5280' />, <xref target="RFC7748"/>, and <xref target="RFC8032"/> apply accordingly.
      </t>

      <t>
        The procedures for going from a private key to a public key are different for when used with Diffie-Hellman and when used with Edwards Signatures.
        This means that the same public key cannot be used for both ECDH and EdDSA.
      </t>

      <!--
      <t>
        In the original design of Ed25519 signatures, there was a known attack between the pure and the pre-hash version of the signatures.
        This has since been corrected in the final version of the design.
        The initial problem meant that there was a known attack, and therefore a known reason to forbid the use of Ed25519 keys with the Ed25519ph signature scheme and visa versa.
        With the change in the design this attack has been prevented.
        This does not mean that the same Ed25519 key should be used with both schemes, there still may be attacks where collisions can be found.
        For this reason, the same keys are not to be used for the pure and pre-hash versions of the scheme.
        This applies to both curve 25519 and curve 448.
        </t>
        -->

    </section>

  </middle>

  <back>

    <references title="Normative References">

      &rfc2119;
      &rfc5280;
      &rfc5480;
      &rfc7748;
      &eddsa;
      &rfc5958;
      &rfc8174;

    </references>

    <references title="Informative References">

      &rfc3279;
      &rfc4055;
      &rfc5639;
      <!-- Remove for pre-hash
           &rfc5755;
           -->
<!--      &rfc5758; -->
<!--      &rfc5915; -->
&rfc7468;
&iana;

    </references>

    <section title="Invalid Encodings">
      <t>
        There are a number of things that need to be dealt with when a new key part is decoded and imported into the system.
        A partial list of these includes:
        <list style="symbols">
          <t>
            ASN.1 encoding errors:
            Two items are highlighted here.
            First, the use of an OCTET STRING rather than a BIT STRING for the public key.
            This was an incorrect copy of the structure from <xref target="RFC5958"/> which was corrected before publication.
            However, any early implementation may have this wrong.
            Second, the value of the version field is required to be 0 if the publicKey is absent and 1 if present.
            This is called out in <xref target="RFC5958"/> but is not duplicated in the main text.
          </t>
          <t>
            Key encoding errors:
            Both <xref target="RFC7748"/> and <xref target="RFC8032"/> have formatting requirements for keys that need to be enforced.
            In some cases the enforcement is done at the time of importing, for example doing masking or a mod p operation.
            In other cases the enforcement is done by rejecting the keys and having an import failure.
          </t>
          <t>
            Key mismatch errors: If a public key is provided, it may not agree with the private key either because it is wrong or the wrong algorithm was used.
          </t>
        </list>
      </t>

      <t>
        Some systems are also going to be stricter on what they accept.
        As stated in <xref target="RFC5958"/>, BER decoding of OneAsymmetricKey objects is a requirement for compliance.
        Despite this requirement, some acceptors will only decode DER formats.
        The following is a BER encoding of a private key, as such is is valid, but it may not be accepted by many systems.
      </t>

      <figure><artwork>
-----BEGIN PRIVATE KEY-----
MIACAQAwgAYDK2VwAAAEIgQg1O5y2/kTWErVttjx92n4rTr+fCjL8dT74Jeoj0R1W
EIAAA==
-----END PRIVATE KEY-----      
      </artwork></figure>



      <t>
        What follows here is a brief sampling of some incorrect keys.
      </t>

      <t>
        In the following example, the private key does not match the masking requirements for X25519.
        For this example the top bits are set to zero and the bottom three bits are set to 001.
      </t>

      <figure><artwork>
-----BEGIN PRIVATE KEY-----
MFMCAQEwBQYDK2VuBCIEIPj///////////////////////////////////////8/oS
MDIQCEfA0sN1I082XmYJVRh6NzWg92E9FgnTpqTYxTrqpaIg==
-----END PRIVATE KEY-----
      </artwork></figure>

      <t>
        In the following examples, the key is the wrong length because an all zero byte has been removed.
        In one case the first byte has been removed, in the other case the last byte has been removed.
      </t>

      <figure><artwork>
-----BEGIN PRIVATE KEY-----
MFICAQEwBQYDK2VwBCIEIC3GfeUYbZGTAhwLEE2cbvJL7ivTlcy17VottfN6L8HwoS
IDIADBfk2Lv/J8H7YYwj/OmIcDx++jzVkKrKwS0/HjyQyM
-----END PRIVATE KEY-----
      </artwork></figure>

      <figure><artwork>
-----BEGIN PRIVATE KEY-----
MFICAQEwBQYDK2VwBCIEILJXn1VaLqvausjUaZexwI/ozmOFjfEk78KcYN+7hsNJoS
IDIACdQhJwzi/MCGcsQeQnIUh2JFybDxSrZxuLudJmpJLk
-----END PRIVATE KEY-----
      </artwork></figure>


    </section>
  </back>
</rfc>
